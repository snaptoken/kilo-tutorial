# 基础环境搭建

![Step 1 of a Lego instruction booklet: a single Lego piece](i/lego-step-one.png)

嗯，第一步。你难道不喜欢从一块干净的地面上从头开始吗？然后从选第一块砖开始搭建你气势宏伟的城堡？

然而，不幸的是，你正在搭建的是一个*计算机程序*，第一步可以变的非常复杂并且让人迷惑。你需要确定你已经搭建好你正在使用编程语言的环境并且弄明白怎么在这个环境下编译并运行你的程序。

不过，好消息是，我们这个程序并不依赖于任何外部库，所以你不用担心C语言编译器和标准库以外的东西。（我们也会使用`make`程序。）如果要检查一下你是否装了一个C语言编译器，尝试在命令行下运行`cc --version`(`cc`代表“C编译器”(C compiler))。要检查是否你有`make`程序，尝试在命令行下运行`make -v`。

## 怎么安装一个C语言编译器...

### ...在Windows上

你需要**在Windows上安装一种（类）Linux环境**，这是因为我们的编辑器需要直接和终端交互并运作在一个较低的层级上。这需要使用`<termios.h>`头文件，然而在Windows上并没有这个文件。我建议你使用[Bash on Windows](https://msdn.microsoft.com/zh-cn/commandline/wsl/about)或者[Cygwin](https://www.cygwin.com/)。

**Bash on Windows**：Windows10上的Ubuntu子系统。请确保你的系统是64位的Windows10最新版。这里是[安装教程](https://msdn.microsoft.com/zh-cn/commandline/wsl/install_guide)（英文）。安装结束后，直接在CMD或者Powershell中运行`bash`命令即可进入Linux环境。进入Linux子系统之后请运行`sudo apt-get install gcc make`安装GCC编译器和`make`。如果安装让你等了太久时间，请搜索*更换Ubuntu软件源*；如果使用`sudo`让你浪费了太多时间，请看[这个](https://superuser.com/questions/1108197)。

**Cygwin**: 从[这里](https://cygwin.com/install.html)下载安装包进行安装。在安装程序询问你要安装哪些程序包这一步，在`devel`这个选项内选中`gcc-core`和`make`这两个包。使用Cygwin很简单，运行Cygwin的终端即可。和Linux子系统不同，Cygwin下的`home`目录和你的Windows用户账户目录不是一个。也就是说，假如你在`C:\cygwin64`下安装了Cygwin，你的`home`目录就在`C:\cygwin64\home\yourname`。所以如果你想在Cygwin环境外面使用这个编辑器写代码的话，这个文件夹就是你应该去找程序的地方。

### ...在macOS上

当你尝试运行`cc`命令的时候，一个对话框会跳出来问你是否安装命令行开发者工具。你也可以运行`xcode-select --install`命令来让这个框弹出。之后你只需要点击“安装”，包括C编译器和`make`在内的众多开发工具都会帮你装好。

### ...在Linux上

在Ubuntu上面，运行`sudo apt-get install gcc make`即可。其他发行版应该也有`gcc`和`make`这两个包，搜索一下你的发行版配合“gcc make”这两个关键词看看。

## `main()`函数

新建一个文件并命名为`kilo.c`并且在其中写入一个`main()`函数。（`kilo`就是我们要做的编辑器的名字啦。）

{{main}}

在C语言中，你需要把所有*可运行的代码*放进*函数*里。然而，`main()`函数对于C语言来说是一个特殊的存在。这个函数是任何一个C程序的默认起点。当你从一个`main()`函数*返回*(`return`)后，程序就退出并且返回一个整形数字给操作系统。`0`意味着程序正常退出。

C语言是一种编译型语言。这意味着我们需要先使用我们的C语言编译器把源代码编译成可执行文件再运行。之后我们就可以像从命令行运行其他程序那样运行这个可执行文件。

要编译`kilo.c`，只需在你的终端中运行`cc kilo.c -o kilo`。如果什么错误都没发生，那么会多出一个名叫`kilo`的可执行文件。`-o`参数意味着”输出“("output")，并且特别指定了输出的程序名应该叫做`kilo`。

要运行`kilo`，在你的终端中输入`./kilo`并按下*回车*(<kbd>Enter</kbd>)。这个程序不会有任何输出，但是你可以看看它的退出状态（就是`main()`函数中返回那个）通过运行`echo $?`，结果应该是`0`.

## 使用`make`编译

每次都输入`cc kilo.c -o kilo`重新编译是很累人的。`make`会在你每次输入`make`的时候帮你编译你的程序。你只需要提供一个`Makefile`来告诉`make`该怎么编译你的程序。

创建一个新文件叫做`Makefile`，是的没有任何后缀。然后在这个文件中输入如下内容：

{{make}}

这个文件的第一行说`kilo`是我们想编译的程序，并且`kilo.c`对于我们的编译进程是一个必要的文件。第二行特别指出实际上我们需要运行的命令来从`kilo.c`中编译出`kilo`。确保第二行的缩进是使用<kbd>Tab</kbd>键来进行的，而且不要插入任何空格。你可以随心所欲的缩进的C语言源文件，但是对于`Makefile`，你只能使用<kbd>Tab</kbd>。

我们在编译命令上添加了这些东西：
* `$(CC)` 是`make`默认的`cc`变量。
* `-Wall`代表**所有的错误**(**all** **W**arnings)，并且让编译器在当你的代码看起来并不像有技术错误，但是看起来是错误的或者是有问题的用法时提出警告，比如说在初始化变量前就使用他们。
* `-Wextra`和`-pedantic`会启用更多的错误提示。对于这个教程的每一步，当你编译你的程序时，编译器都不应该提示你有任何错误，除了在某些情况下会提示*未使用的变量*。如果你发现编译器报告了任何其他错误，检查你的代码是否和这一步叫承重的代码完全一致。
* `-std=c99`指出了我们编译时使用的*C语言标准*(**st**an**d**ard)。我们教程中使用的是[C99标准](https://en.wikipedia.org/wiki/C99)(英文页面)。C99允许我们在函数中任何地方声明一个变量，而[ANSI C](https://en.wikipedia.org/wiki/ANSI_C)(英文页面)则要求在每一个语句块或者函数的最顶部声明所有变量。

现在我们有`Makefile`了，尝试运行`make`来编译我们的程序吧。

执行后也许会输出``make: `kilo' is up to date.``。这一句输出告诉我们，在检查过每一个文件的最后被修改时间后，当前的`kilo.c`已经被编译过，也就是说现在是最新的版本了。如果`kilo`仅仅在`kilo.c`被修改后修改过，之后`make`会认为`kilo.c`已经被编译过，所以它就不会再一次编译了。如果`kilo.c`是最后一个被修改的，那么`make`会重新编译`kilo.c`。这个功能对于那些有很多依赖的项目来说很实用，因为有些时候我们只修改其中的几项，而其他的不需要被一次又一次的重新编译。

尝试把`kilo.c`中的返回值改成不是`0`，然后运行`make`，你就可以看到它被编译了。运行`./kilo`，并且尝试运行`echo $?`命令来看看返回的值是不是你修改的那个。之后再把它改回`0`，重新编译，再运行，确保它现在返回`0`了。

在这个教程的每一步之后，你都会想重新编译`kilo.c`来看看是不是有报错，之后跑一下`./kilo`。重新编译是一件很容易被忘记的事情，你可能直接运行了`./kilo`，然后很奇怪为什么你在`kilo.c`中做出来的修改没用。你必须重新编译来让`kilo.c`中做出的修改反映到`kilo`中。

在[下一章](02.enteringRawMode.html)中，我们要写点代码让终端进入**原始模式**("raw mode")，并且读取每一次来自用户的按键输入。